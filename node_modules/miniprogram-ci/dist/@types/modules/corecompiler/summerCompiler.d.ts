/// <reference types="node" />
import { MiniProgramDevtools, MiniProgramCore, ExtJSON } from '../../types';
import { FileInfo } from './summer/graph/basegraph';
import { EFilterCode } from '../../config/config';
import { SubProcessProxy } from '../../utils/subprocess/processManager';
import { IMessageHub } from '../../utils/messageHub';
import { BaseCoreCompiler } from './baseCompiler';
import { Analyzer } from '../../common/code-analyse';
export { ICompilerStatus } from './summer/summer';
export declare class SummerCompiler extends BaseCoreCompiler {
    project: MiniProgramCore.IPreCompileProject;
    private cachePath;
    private projectInfo;
    private devtoolMessagehub;
    private analyzer;
    private _filterFactory?;
    private onInitFinished?;
    readonly isSummer = true;
    subProcessManager: SubProcessProxy | undefined;
    private promiseCache;
    private _taskCache;
    private messageHub;
    private progressUpdateFromCompileOptions?;
    _status: MiniProgramDevtools.ICompilerStatus | undefined;
    private _eventAdded;
    private _locale;
    private devCodeCacheByPath;
    constructor(project: MiniProgramCore.IPreCompileProject, cachePath: string, projectInfo: MiniProgramDevtools.IDevtoolsProjectInfo, devtoolMessagehub: IMessageHub, analyzer: Analyzer | null, _filterFactory?: MiniProgramDevtools.IFilterFactory | undefined, onInitFinished?: ((e?: Error) => void) | undefined);
    get status(): MiniProgramDevtools.ICompilerStatus | undefined;
    protected init(): Promise<void>;
    private loadStatus;
    destroy(): void;
    clearCache(): Promise<void>;
    updateOptions(options: MiniProgramDevtools.IDevtoolsProjectInfo): void;
    private addProjectListener;
    private removeProjectListener;
    onFileChange: (type: 'unlink' | 'unlinkDir' | 'add' | 'addDir' | 'change', targetPath: string) => void;
    onPreCompileOptionsChange: (data: any) => Promise<void>;
    private invalidCodeCache;
    private onProgressUpdate;
    private getConf;
    getPackageFiles(graphId: MiniProgramDevtools.GraphId, root: string, resultType?: MiniProgramCore.IResultType, useCache?: boolean): Promise<FileInfo[]>;
    _getPackageFiles: (graphId: import("../../types").MiniProgramCI.ProjectType, root: string, resultType?: MiniProgramCore.IResultType) => Promise<FileInfo[]>;
    private isMiniappPlatformInclude;
    filterUnusedFiles(isGame: boolean, abFilePath: string, resultType: MiniProgramCore.IResultType): Promise<EFilterCode>;
    private filterFactory;
    private getCodeByFileList;
    getExtJSON(): Promise<ExtJSON.IExtJSON>;
    getAppJSON(): Promise<any>;
    getGameJSON(): Promise<any>;
    getSiteMapJSON(): Promise<any>;
    getPageJSON(pagePath: string): Promise<any>;
    getAllPageAndComponent(): Promise<string[]>;
    getAllSortedJSFiles(): Promise<{
        otherJsFiles: string[];
        jsPagesFiles: string[];
        components: string[];
    }>;
    getAllWxmlAndWxsFiles(): Promise<{
        wxmlFiles: string[];
        wxsFiles: string[];
        content: Record<string, string>;
    }>;
    getPackageWxmlAndWxsFiles(packagePath: string): Promise<{
        wxmlFiles: string[];
        wxsFiles: string[];
        content: Record<string, string>;
    }>;
    getPackageWxssFileList(packagePath: string): Promise<any[]>;
    getPackageWxssFiles(packagePath: string): Promise<{
        wxssFiles: string[];
        content: Record<string, string>;
    }>;
    getWxssMap(graphId: MiniProgramDevtools.GraphId, wxssPath: string): string | import("../../types").MiniProgramSummer.SourceMap | undefined;
    getMainPkgSortedJSFiles(): Promise<{
        hasAppJS: boolean;
        allFiles: string[];
        pageFiles: string[];
        functionalPageFiles: string[];
        workerFiles: string[];
        componentFiles: string[];
        otherFiles: string[];
    }>;
    getSubPkgSortedJSFiles(rootPath: string): Promise<{
        entryJS: string;
        allFiles: string[];
        pageFiles: string[];
        componentFiles: string[];
        otherFiles: string[];
    }>;
    compileJSList(options: {
        root: string;
        fileList: string[];
    }): Promise<{
        isLargeFile?: boolean | undefined;
        isBabelIgnore?: boolean | undefined;
        helpers?: string[] | undefined;
        filePath: string;
        code: string;
        map: string | import("../../types").MiniProgramSummer.SourceMap | undefined;
        mtime: number | undefined;
    }[]>;
    compileJS(options: {
        root: string;
        filePath: string;
        babelRoot: string;
        sourceCode?: string;
        setting: MiniProgramDevtools.IProjectSetting;
        resultType?: MiniProgramCore.IResultType;
    }): Promise<{
        isLargeFile?: boolean | undefined;
        isBabelIgnore?: boolean | undefined;
        helpers?: string[] | undefined;
        filePath: string;
        code: string;
        map: string | import("../../types").MiniProgramSummer.SourceMap | undefined;
        mtime: number | undefined;
    }>;
    compile(options: MiniProgramCore.ICompileOptions): Promise<MiniProgramDevtools.ICompileResult>;
    private compileOther;
    compile2(options: MiniProgramCore.ICompileOptions): Promise<MiniProgramDevtools.ICompileResult>;
    getPluginJSON(localPath?: string): Promise<any>;
    getPluginPageJSON(pagePath: string): Promise<any>;
    getPluginComponents(): Promise<string[]>;
    getPluginJSFiles(): Promise<{
        jsFiles: string[];
        content: Record<string, string>;
    }>;
    getPluginWxssFiles(): Promise<{
        wxssFiles: string[];
        content: Record<string, string>;
    }>;
    getPluginWxmlAndWxsFiles(): Promise<{
        wxmlFiles: string[];
        wxsFiles: string[];
        content: Record<string, string>;
    }>;
    checkThemeJSON(options: {
        themeLocation: string;
        isPlugin?: boolean;
    }): Promise<any>;
    setProxy(proxyUrl: string): void;
    setLocale(locale: string): void;
    uglifyFileNames(project: MiniProgramDevtools.IDevtoolsProject, result: Record<string, string | Buffer>, nameMapping: Record<string, string>): Promise<MiniProgramCore.IAnyObject>;
    getMPFileInfo(): Promise<MiniProgramCore.IFileInfos>;
    getPluginFileInfo(): Promise<MiniProgramCore.IFileInfos>;
    getCompAndPagesOfConf(): Promise<{
        pages: Record<string, any>;
        comps: Record<string, any>;
    }>;
    getFiltedFileListReason(resultType: MiniProgramCore.IResultType): Promise<{
        file: string;
        code: number;
    }[]>;
}
