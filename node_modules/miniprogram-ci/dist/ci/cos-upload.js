"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.uploadByCosSafely=exports.uploadByCos=exports.innerRequest=void 0;const tslib_1=require("tslib"),url_config_1=require("../config/url.config"),tools_1=require("../utils/tools"),request_1=require("../utils/request"),sign_1=require("../utils/sign"),pack_1=require("./utils/pack"),config_1=require("../config/config"),index_1=require("../utils/asyncTask/index"),log=tslib_1.__importStar(require("../utils/log")),jsonParse_1=require("../utils/jsonParse"),__1=require(".."),zlib=require("zlib"),crypto=require("crypto"),COS=require("cos-nodejs-sdk-v5");async function putBufferToCos(e,t){const r=new COS({Proxy:(0,request_1.getCiProxy)(),getAuthorization(e,r){r({TmpSecretId:t.secret_id,TmpSecretKey:t.secret_key,XCosSecurityToken:t.token,ExpiredTime:t.expired_time})}});try{return await new Promise((o,a)=>{r.putObject({Bucket:t.bucket,Region:"ap-shanghai",Key:t.object,Body:e,onProgress(e){}},(e,t)=>{if(e)return console.error(e),a(e.error);o(t)})})}catch(e){throw new Error("upload to cos failed: "+e.message)}}async function innerRequest(e,t){const r=await(0,request_1.request)({url:e,method:"post",body:t,headers:{"content-type":"application/json"}});let o;try{o=JSON.parse(r.body)}catch(t){const r=`request ${e} failed: resp body is not a valid json`;throw log.error(r),new Error(r)}if(0!==o.errCode){const e=`request failed, errCode: ${o.errCode}, errMsg: ${o.errMsg}`;throw log.error(e),new Error(e)}return o.data}async function uploadByCos(e,t,r,o){let a;try{const e=await(0,sign_1.getSignature)(r.privateKey,r.appid);a=await innerRequest(url_config_1.GET_UPLOAD_TOKEN,JSON.stringify({appid:r.appid,signature:e,robot:o}))}catch(e){return console.error("uploadToken error",e),{fallback:!0}}const i=e,s=crypto.randomBytes(12),n=crypto.createCipheriv("aes-256-gcm",Buffer.from(a.crypt_key,"base64"),s),u=Buffer.concat([n.update(i),n.final()]),c=n.getAuthTag(),p=Buffer.alloc(1);p.writeUInt8(c.length+s.length,0);const l=Buffer.concat([p,c,s,u]),d=Date.now();await putBufferToCos(l,a);const f=Date.now()-d,g=(0,tools_1.generateMD5)(i),_=await(0,sign_1.getSignature)(r.privateKey,r.appid),y=`${t}&task_id=${a.task_id}&new_hash=${g}&upload_cos_cost_time=${f}`;log.info("request url:",y);const w=await(0,request_1.request)({url:y,method:"post",body:zlib.gzipSync((0,pack_1.pack)({[index_1.SIGNATURE_FILE_NAME]:JSON.stringify({signature:_,version:config_1.CI_VERSION})}).buffer)});if(0!==(0,jsonParse_1.jsonRespParse)(w.body.toString(),t).errCode)throw new Error(w.body.toString());for(;;){const e=await(0,sign_1.getSignature)(r.privateKey,r.appid),t=await innerRequest(`${url_config_1.GET_ASYNC_RESULT}?task_id=${a.task_id}`,JSON.stringify({appid:r.appid,signature:e,robot:o}));if(1!==t.status){if(0===t.status)return{fallback:!1,body:t,uploadCOSCostTime:f};if(3===t.status)throw new Error(`upload failed with status ${t.status}, task not found`);throw new Error("upload failed with status "+t.status)}await new Promise(e=>{setTimeout(e,1e3)})}}async function uploadByCosSafely(e,t,r,o){let a;try{const e=await(0,sign_1.getSignature)(r.privateKey,r.appid);a=await innerRequest(url_config_1.GET_UPLOAD_INFO,JSON.stringify({appid:r.appid,signature:e,robot:o}))}catch(e){return console.error("getUploadInfo failed",e),{fallback:!0}}const i=crypto.randomBytes(12),s=crypto.createCipheriv("aes-256-gcm",Buffer.from(a.crypt_key,"base64"),i),n=Buffer.concat([s.update(e),s.final()]),u=s.getAuthTag();console.info("nonce:%s, nonce size:%d",i,i.length),console.info("tag:%s, tag size:%d",u,u.length),console.info("encrypted size:%d",n.length);const c=Buffer.alloc(1);c.writeUInt8(u.length+i.length,0);const p=Buffer.concat([c,u,i,n]),l=Date.now();try{await __1.cosUpload.uploadToCosCore({uploadBuf:p,region:"ap-shanghai",getUploadInfoFunc:async()=>a,getAuthFunc:async e=>{let t,i={},s={};switch(e.action){case"name/cos:InitiateMultipartUpload":i={uploads:""};break;case"name/cos:ListMultipartUploads":i={uploads:"",prefix:a.object},s={};break;case"name/cos:UploadPart":case"name/cos:ListParts":case"name/cos:CompleteMultipartUpload":i={uploadId:e.uploadId},s={};break;default:throw new Error("no action ")}try{const n=await(0,sign_1.getSignature)(r.privateKey,r.appid),u=await innerRequest(url_config_1.GET_UPLOAD_SIGN,JSON.stringify({appid:r.appid,signature:n,robot:o,signOpts:JSON.stringify({checksum:a.checksum,action:e.action,upload_id:e.uploadId,headers:s,params:i})}));t={Authorization:u.sign,SecurityToken:u.token,AuthExpireTime:u.expired_time}}catch(e){throw console.info("uploadToCos safely failed ,start fallback"),console.log(e),new Error("")}return t}})}catch(e){return{fallback:!0}}const d=Date.now()-l,f=(0,tools_1.generateMD5)(e),g=await(0,sign_1.getSignature)(r.privateKey,r.appid),_=`${t}&task_id=${a.task_id}&new_hash=${f}&upload_cos_cost_time=${d}`;log.info("request url:",_);const y=await(0,request_1.request)({url:_,method:"post",body:zlib.gzipSync((0,pack_1.pack)({[index_1.SIGNATURE_FILE_NAME]:JSON.stringify({signature:g,version:config_1.CI_VERSION})}).buffer)});if(0!==(0,jsonParse_1.jsonRespParse)(y.body.toString(),t).errCode)throw new Error(y.body.toString());for(;;){const e=await(0,sign_1.getSignature)(r.privateKey,r.appid),t=await innerRequest(`${url_config_1.GET_ASYNC_RESULT}?task_id=${a.task_id}`,JSON.stringify({appid:r.appid,signature:e,robot:o}));if(1!==t.status){if(0===t.status)return{fallback:!1,body:t,uploadCOSCostTime:d};if(3===t.status)throw new Error(`upload failed with status ${t.status}, task not found`);throw new Error("upload failed with status "+t.status)}await new Promise(e=>{setTimeout(e,1e3)})}}exports.innerRequest=innerRequest,exports.uploadByCos=uploadByCos,exports.uploadByCosSafely=uploadByCosSafely;